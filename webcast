#!/usr/bin/env python
#coding=utf-8

import sys
import os
import pty
import signal
import tty
import array
import termios
import fcntl
import select
import time
import json
import getopt
import subprocess
import httplib, urllib
import socket
import glob
import bz2
import ConfigParser
import uuid
import shutil
import StringIO
import json

import threading
import alsaaudio
import wave,time

################################
import gtk.gdk
from Xlib.display import Display
import os
import time
import gtk
from Tkinter import *
import tkMessageBox

from websocket import create_connection

ws = ''
roomid = 0
window = Tk()
window.wm_withdraw()


key_ctrl_f4 = [0, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0]
#################################


SCRIPT_NAME = os.path.basename(sys.argv[0])
BASE_DIR = os.path.expanduser("~/.ascii.io")

record_exit = 0
common_path = ""
start_time  = ""




#################

class capture_screen(threading.Thread):
      def __init__(self):
             threading.Thread.__init__(self)

      def run(self):
  	global record_exit
        disp = Display()
	file = open("%s/picture.time"% common_path,"a")
	file.close()
        while record_exit !=1:
                keymap = disp.query_keymap()
                if keymap == key_ctrl_f4:
                        screensave(int(time.time()))
                time.sleep(0.10)


def screensave(filename):
        global common_path,start_time
        w = gtk.gdk.get_default_root_window()
        sz = w.get_size()
        pb = gtk.gdk.Pixbuf(gtk.gdk.COLORSPACE_RGB,False,8,sz[0],sz[1])
        pb = pb.get_from_drawable(w,w.get_colormap(),0,0,0,0,sz[0],sz[1])
        if (pb != None):
                pb.save("%s/%s.png"% (common_path,str(filename)),"png")
	file = open("%s/picture.time"% common_path,"a")
	file.write("%s %s.png\n"% (filename-start_time,str(filename)))
	file.close()
        #child_pid = os.fork()
	#if child_pid == 0: #child
	#	display_dialog()

	print "æŠ“èŽ·å›¾ç‰‡æˆåŠŸ"


def  display_dialog():
	dialog = gtk.Dialog("ok", None, 0, (gtk.STOCK_OK, gtk.RESPONSE_OK))
        dialog.set_default_size(250, 200)
        label = gtk.Label("æŠ“å›¾æˆåŠŸ")
        dialog.vbox.pack_start(label, True, True, 0)
        dialog.show_all()
        response = dialog.run()
        dialog.destroy()
	exit()
	gtk.main()

###################

class AsciiCast(object):
    QUEUE_DIR = BASE_DIR + "/queue"

    def __init__(self, api_url, user_token, command, title, record_input, always_yes):
	global common_path,start_time
        self.api_url = api_url
        self.user_token = user_token
	start_time = int(time.time())
        self.path = AsciiCast.QUEUE_DIR + "/%i" % start_time
	cmd = "mkdir -p %s"% self.path
        os.system(cmd)
	common_path = self.path
        self.command = command
        self.title = title
        self.record_input = record_input
        self.duration = None
        self.always_yes = always_yes
	r1 = capture_screen()
	r1.start()

    def create(self):
        self._record()
        if self.confirm_upload():
            #return self._upload()
	    return 
        else:
            self._delete()

    def confirm_upload(self):
        if self.always_yes:
            return True

	global record_exit
	record_exit = 1
        sys.stdout.write("~ Do you want to upload it? [Y/n] ")
        answer = sys.stdin.readline().strip()
        return answer == 'y' or answer == 'Y' or answer == ''

    def _record(self):
	cmd = "mkdir -p %s"% self.path
        os.system(cmd)
        #os.makedirs(self.path)
        self.recording_start = time.time()
        command = self.command or os.environ['SHELL'].split()
        PtyRecorder(self.path, command, self.record_input).run()
        self.duration = time.time() - self.recording_start
        self._save_metadata()

    def _save_metadata(self):
        info_file = open(self.path + '/meta.json', 'wb')

        # RFC 2822
        recorded_at = time.strftime("%a, %d %b %Y %H:%M:%S +0000",
                                    time.gmtime(self.recording_start))

        command = self.command and ' '.join(self.command)
        uname = self._get_cmd_output(['uname', '-srvp'])
        username = os.environ['USER']
        shell = os.environ['SHELL']
        term = os.environ['TERM']
        lines = int(self._get_cmd_output(['tput', 'lines']))
        columns = int(self._get_cmd_output(['tput', 'cols']))

        data = {
            'username'   : username,
            'user_token' : self.user_token,
            'duration'   : self.duration,
            'recorded_at': recorded_at,
            'title'      : self.title,
            'command'    : command,
            'shell'      : shell,
            'uname'      : uname,
            'term'       : {
                'type'   : term,
                'lines'  : lines,
                'columns': columns
            }
        }

        json_string = json.dumps(data, sort_keys=True, indent=4)
        info_file.write(json_string + '\n')
        info_file.close()

    def _get_cmd_output(self, args):
        process = subprocess.Popen(args, stdout=subprocess.PIPE)
        return process.communicate()[0].strip()

    def _upload(self):
        url = Uploader(self.api_url, self.path).upload()
        if url:
            print url
            return True
        else:
            return False

    def _delete(self):
        #shutil.rmtree(self.path)
	print "No rmtree", self.path 


class TimedFile(object):
    '''File wrapper that records write times in separate file.'''

    def __init__(self, filename):
        self.filename = filename
	print filename
        self.data_file = StringIO.StringIO()
        self.time_file = StringIO.StringIO()

        self.old_time = time.time()

    def write(self, data):
        self.data_file.write(data)
        now = time.time()
        delta = now - self.old_time
        self.time_file.write("%f %d\n" % (delta, len(data)))
        self.old_time = now

    def close(self):
        mode = 'w'

        bz2_data_file = bz2.BZ2File(self.filename, mode)
        bz2_data_file.write(self.data_file.getvalue())
        bz2_data_file.close()

        bz2_time_file = bz2.BZ2File(self.filename + '.time', mode)
        bz2_time_file.write(self.time_file.getvalue())
        bz2_time_file.close()

        self.data_file.close()
        self.time_file.close()

class PtyRecorder(object):
    '''Pseudo-terminal recorder.

    Creates new pseudo-terminal for spawned process
    and saves stdin/stderr (and timing) to files.
    '''

    def __init__(self, path, command, record_input):
        self.master_fd = None
        self.path = path
        self.command = command
        self.record_input = record_input

    def run(self):
        self._open_files()
        self.reset_terminal()
        self._write_stdout('~ Asciicast recording started. Hit ^D (that\'s Ctrl+D) or type "exit" to finish.\n\n')
        success = self._spawn()
        self.reset_terminal()
        self._write_stdout('~ Asciicast recording finished.\n')
        self._close_files()
        return success

    def reset_terminal(self):
        subprocess.call(["reset"])

    def _open_files(self):
        self.stdout_file = TimedFile(self.path + '/stdout')
        if self.record_input:
            self.stdin_file = TimedFile(self.path + '/stdin')

    def _close_files(self):
        self.stdout_file.close()
        if self.record_input:
            self.stdin_file.close()

    def _spawn(self):
        '''Create a spawned process.

        Based on pty.spawn() from standard library.
        '''

        assert self.master_fd is None

        pid, self.master_fd = pty.fork()

        if pid == pty.CHILD:
            os.execlp(self.command[0], *self.command)

        old_handler = signal.signal(signal.SIGWINCH, self._signal_winch)

        try:
            mode = tty.tcgetattr(pty.STDIN_FILENO)
            tty.setraw(pty.STDIN_FILENO)
            restore = 1
        except tty.error: # This is the same as termios.error
            restore = 0

        self._set_pty_size()

        try:
            self._copy()
        except (IOError, OSError):
            if restore:
                tty.tcsetattr(pty.STDIN_FILENO, tty.TCSAFLUSH, mode)

        os.close(self.master_fd)
        self.master_fd = None
        signal.signal(signal.SIGWINCH, old_handler)

        return True

    def _signal_winch(self, signal, frame):
        '''Signal handler for SIGWINCH - window size has changed.'''

        self._set_pty_size()

    def _set_pty_size(self):
        '''
        Sets the window size of the child pty based on the window size
        of our own controlling terminal.
        '''

        assert self.master_fd is not None

        # Get the terminal size of the real terminal, set it on the pseudoterminal.
        buf = array.array('h', [0, 0, 0, 0])
        fcntl.ioctl(pty.STDOUT_FILENO, termios.TIOCGWINSZ, buf, True)
        fcntl.ioctl(self.master_fd, termios.TIOCSWINSZ, buf)

    def _copy(self):
        '''Main select loop.

        Passes control to self._master_read() or self._stdin_read()
        when new data arrives.
        '''

        assert self.master_fd is not None
        while 1:
            try:
                rfds, wfds, xfds = select.select([self.master_fd, pty.STDIN_FILENO], [], [])
            except select.error, e:
                if e[0] == 4:   # Interrupted system call.
                    continue

            if self.master_fd in rfds:
                data = os.read(self.master_fd, 1024)

                if len(data) == 0:
                  break

                self._handle_master_read(data)

            if pty.STDIN_FILENO in rfds:
                data = os.read(pty.STDIN_FILENO, 1024)
                self._handle_stdin_read(data)

    def _handle_master_read(self, data):
        '''Handles new data on child process stdout.'''
	wsdata={"data":data,"action":"teacher","room":roomid}
	ws.send(json.dumps(wsdata))
        self._write_stdout(data)
        self.stdout_file.write(data)

    def _handle_stdin_read(self, data):
        '''Handles new data on child process stdin.'''

        self._write_master(data)
        if self.record_input:
            self.stdin_file.write(data)

    def _write_stdout(self, data):
        '''Writes to stdout as if the child process had written the data.'''
        os.write(pty.STDOUT_FILENO, data)

    def _write_master(self, data):
        '''Writes to the child process from its controlling terminal.'''

        assert self.master_fd is not None

        while data != '':
            n = os.write(self.master_fd, data)
            data = data[n:]


class Uploader(object):
    '''Asciicast uploader.

    Uploads recorded script to website using HTTP based API.
    '''

    def __init__(self, api_url, path):
        self.api_url = api_url
        self.path = path

    def upload(self):
        print '~ Uploading...'

        files = {
                     'meta': 'meta.json',
                   'stdout': 'stdout',
            'stdout_timing': 'stdout.time',
                      'mp3': 'record.mp3',
           'picture_timing': 'picture.time',
        }

        if os.path.exists(self.path + '/stdin'):
            files['stdin']        = 'stdin'
            files['stdin_timing'] = 'stdin.time'

	cmd = "lame %s %s"% (common_path+"/record.wav",common_path+"/record.mp3")
	os.system(cmd)

        fields = ["-F asciicast[%s]=@%s/%s" % (f, self.path, files[f]) for f in files]


        cmd = "curl -sSf -o - %s %s" % (' '.join(fields), '%s/api/asciicasts' % self.api_url)

	print cmd 
        process = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE,
                                   stderr=subprocess.PIPE)
        stdout, stderr = process.communicate()

        if stderr:
            # print >> sys.stderr, stderr
            # sys.stderr.write(stderr)
            os.write(2, stderr)

        if stdout:
	    aid = stdout.split('/')
	    f_pic     =  open("%s/picture.time"% common_path)
	    pic_lines =  f_pic.readlines()
	    f_pic.close()
	    for pic_file in pic_lines:
		pic_filename = pic_file.strip().split(" ")[1]
		
	    	cmd = "curl -sSf -o - -F picture[picture_file]=@"+self.path +"/"+ pic_filename + " " + self.api_url+"/a/"+ aid[-1]+ "/pictures"
            	process = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE,
                                   stderr=subprocess.PIPE)
		print cmd
        	filestdout, filestderr = process.communicate()
            self._remove_files()
            return stdout
        else:
            return None

    def _remove_files(self):
	shutil.rmtree(self.path)


def check_pending():
    num = len(pending_list())
    if num > 0:
        print 'Warning: %i recorded asciicasts weren\'t uploaded. ' \
              'Run "%s upload" to upload them or delete them with "rm -rf %s/*".' \
              % (num, SCRIPT_NAME, AsciiCast.QUEUE_DIR)


def upload_pending(api_url):
    print 'Uploading pending asciicasts...'
    for path in pending_list():
        url = Uploader(api_url, path).upload()
        if url:
            print url


def auth(api_url, user_token):
    url = '%s/connect/%s' % (api_url, user_token)
    print 'Open following URL in your browser to authenticate and/or claim ' \
          'recorded asciicasts:\n\n%s' % url


def pending_list():
    return [os.path.dirname(p) for p in glob.glob(AsciiCast.QUEUE_DIR + '/*/*.time')]


def usage():
    text = '''usage: %s [-h] [-i] [-y] [-c <command>] [-t <title>] [action]

Asciicast recorder+uploader.

Actions:
 rec           record asciicast (this is the default when no action given)
 upload        upload recorded (but not uploaded) asciicasts
 auth          authenticate and/or claim recorded asciicasts

Optional arguments:
 -c command    run specified command instead of shell ($SHELL)
 -t title      specify title of recorded asciicast
 -y            don't prompt for confirmation
 -h, --help    show this help message and exit
 --version     show version information''' % SCRIPT_NAME
    print text


def print_version():
    print 'asciiio 1.0'


def main():
    '''Parses command-line options and creates asciicast.'''
    global ws,roomid
    ws = create_connection("ws://www.codepark.us:8080/")
    try:
        opts, args = getopt.getopt(sys.argv[1:], 'c:t:ihy', ['help', 'version'])
    except getopt.error as msg:
        print('%s: %s' % (sys.argv[0], msg))
        print('Run "%s --help" for list of available options' % sys.argv[0])
        sys.exit(2)

    action = 'rec'
    if sys.argv[1]: 
    	roomid = "room" + sys.argv[1]
   
    config = ConfigParser.RawConfigParser()
    config.add_section('user')
    config.add_section('api')
    config.add_section('record')

    cfg_file = os.path.expanduser('~/.ascii.io/config')
    try:
        config.read(cfg_file)
    except ConfigParser.ParsingError:
        print('Config file %s contains syntax errors' % cfg_file)
        sys.exit(2)

    try:
        user_token = config.get('user', 'token')
    except ConfigParser.NoOptionError:
        user_token = str(uuid.uuid1())
        config.set('user', 'token', user_token)

    try:
        record_input = config.getboolean('record', 'input')
    except ConfigParser.NoOptionError:
        record_input = False

    try:
        api_url = config.get('api', 'url')
    except ConfigParser.NoOptionError:
        api_url = 'http://127.0.0.1:3000'

    if not os.path.isdir(BASE_DIR):
        os.mkdir(BASE_DIR)

    if not os.path.exists(cfg_file):
        with open(cfg_file, 'wb') as configfile:
            config.write(configfile)

    api_url = os.environ.get('ASCII_IO_API_URL', api_url)

    command = None
    title = None
    always_yes = False

    for opt, arg in opts:
        if opt in ('-h', '--help'):
            usage()
            sys.exit(0)
        elif opt == '--version':
            print_version()
            sys.exit(0)
        elif opt == '-c':
            command = arg.split()
        elif opt == '-t':
            title = arg
        elif opt == '-i':
            record_input = True
        elif opt == '-y':
	        always_yes = True

    if roomid == 0:
	print "Please --roomid select room number"
	sys.exit(0)

    if action == 'rec':
        check_pending()
        if not AsciiCast(api_url, user_token, command, title, record_input, always_yes).create():
            sys.exit(1)
    elif action == 'upload':
        upload_pending(api_url)
    elif action == 'auth':
        auth(api_url, user_token)
    else:
        print('Unknown action: %s' % action)
        print('Run "%s --help" for list of available options' % sys.argv[0])


if __name__ == '__main__':
    main()
